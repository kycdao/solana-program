use anyhow::{Result};
// use log::{error, info};
// use metaboss_lib::decode::*;
// use mpl_token_metadata::state::{Creator, Data};
// use mpl_token_metadata::{
//     instruction::{
//         update_metadata_accounts_v2,
//     },
//     ID as TOKEN_METADATA_PROGRAM_ID,
// };
// use rayon::prelude::*;
// use retry::{delay::Exponential, retry};
// use serde::Serializer;
// use serde::Serialize;
// use serde_json::Value;
use anchor_client::solana_client::{
    rpc_client::RpcClient,
    blockhash_query::Source,
};
use solana_sdk::{
    // message::Message,
    // account::Account,
    commitment_config::CommitmentConfig,
    pubkey::Pubkey,
    signature::{read_keypair_file},
    signer::{keypair::Keypair, Signer},
    system_instruction::{create_account, advance_nonce_account},
    transaction::Transaction,
    system_program::{
        ID as SYSTEM_PROGRAM_ID,
    },
    sysvar::rent::{
        ID as RENT_PUBKEY,
    }, instruction::Instruction
};
use spl_associated_token_account::{
    get_associated_token_address,
    create_associated_token_account,
};
use spl_token::{
    instruction::{initialize_mint, mint_to},
    ID as TOKEN_PROGRAM_ID,
};
use std::{str::FromStr};
// use anchor_client::{Client, Cluster, anchor_lang::ToAccountMetas};
// The `accounts` and `instructions` modules are generated by the framework.
use anchor_lang::{InstructionData, ToAccountMetas, AccountDeserialize};
use kyc_dao::{accounts as kycdao_ntnft_accounts, state::KycDaoNftCollection};
use kyc_dao::instruction as kycdao_ntnft_instruction;
use kyc_dao::state as kycdao_ntnft_state;
use base64::encode;

pub const METAPLEX_PROGRAM_ID: &str = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
pub const KYCDAO_PROGRAM_ID: &str = "7CsRBRHVievYBbbm2L3b26wXY4qhXpF12RvokPzyAZsH";
pub const RECEIVER_ADDR: &str  = "F2bYxvcmSpuX3kGEPSfJic4yL5uu6PumoobR6bkyp6sM";
pub const PRICE_FEED_ADDR: &str  = "J83w4HKfqxwcq3BEMMkPFSppX3gqekLyLJBexebFVkix";
pub const NONCE_ADDR: &str = "4XPifD8B43jNLKJL2BqoWFj66NN1MomNA3hFQmGbKd3h";
const MINT_LAYOUT: u64 = 82;

fn main() -> Result<()> {
    println!("Starting...");
    let client = RpcClient::new("https://api.devnet.solana.com".to_string());
    let backend = read_keypair_file(&*shellexpand::tilde("~/.config/solana/dev1.json"))
        .expect("Couldn't read keypair file");
    let receiver = Pubkey::from_str(RECEIVER_ADDR)?;
    let nonce = Pubkey::from_str(NONCE_ADDR)?;

    let tx = prepare_tx(&client, backend, receiver, nonce)?;

    // Serialize the transaction into bytes
    let bytes: Vec<u8> = bincode::serialize(&tx).unwrap();

    // Encode the bytes into a base64 string
    let tx_base64 = encode(&bytes);

    println!("transaction: {:?}", tx_base64);

    Ok(())
}

pub fn create_init_status_ix() -> Result<()> {
    Ok(())
}

pub fn create_update_status_ix() -> Result<()> {
    Ok(())
}

pub fn create_mint_ix(
    client: &RpcClient,
    backend: &Keypair,
    mint_pubkey: Pubkey,
    receiver: Pubkey
) -> Result<Instruction> {
    let metaplex_program_id = Pubkey::from_str(METAPLEX_PROGRAM_ID)?;

    // Derive metadata account
    let metadata_seeds = &[
        "metadata".as_bytes(),
        &metaplex_program_id.to_bytes(),
        &mint_pubkey.to_bytes(),
    ];
    let (metadata_account, _bump) =
        Pubkey::find_program_address(metadata_seeds, &metaplex_program_id);

    let backend_copy = Keypair::from_bytes(&backend.to_bytes())?;
    // let anchor_client = Client::new(Cluster::Devnet, Rc::new(backend_copy));
    let kycdao_ntnft_id = Pubkey::from_str(KYCDAO_PROGRAM_ID)?;
    // let program = anchor_client.program(kycdao_ntnft_id);

    let (collection_account, _bump) =
        Pubkey::find_program_address(&[kycdao_ntnft_state::KYCDAO_COLLECTION_KYC_SEED.as_bytes()], &kycdao_ntnft_id);

    let (status_account, _bump) =
        Pubkey::find_program_address(&[kycdao_ntnft_state::KYCDAO_STATUS_KYC_SEED.as_bytes(), &mint_pubkey.to_bytes()], &kycdao_ntnft_id);

    // Derive associated token account
    let token_account = get_associated_token_address(&receiver, &mint_pubkey);

    let collection_act = client.get_account(&collection_account)?;
    // let mut act_data = &mut collection_act.data.clone();
    
    let collection_state:KycDaoNftCollection = KycDaoNftCollection::try_deserialize(&mut collection_act.data.as_slice())?;
    // let collection_state: Account<KycDaoNftCollection> = collection_act.try_into()?;
    // anchor_lang::AccountDeserialize::try_deserialize(buf)
    // KycDaoNftCollection::from(collection_act);
    // let collection_state: KycDaoNftCollection = collection_act.deserialize_data()?;
    // let collection_state: KycDaoNftCollection = program.account(collection_account)?;

    let ctx = kycdao_ntnft_accounts::MintWithArgs {
            collection: collection_account,
            // receiver: receiver,
            // status: status_account,
            wallet: collection_state.wallet,
            price_feed: Pubkey::from_str(PRICE_FEED_ADDR)?,
            mint_authority: backend.pubkey(),
            mint: mint_pubkey,
            associated_account: token_account,
            token_program: TOKEN_PROGRAM_ID,
            metadata: metadata_account,
            token_metadata_program: metaplex_program_id,
            fee_payer: receiver,
            system_program: SYSTEM_PROGRAM_ID,
            rent: RENT_PUBKEY,
    };

    println!("ctx: {:?}", ctx.to_account_metas(None));

    let anchor_ix = kycdao_ntnft_instruction::MintWithArgs {
        // expiry: 1701436998,
        seconds_to_pay: 0,
        metadata_cid: "QmUDyt1mZEMUMLQ1PQj7UnYvo9phLLG6j3TKV7AvW6P4u6".to_string(),
        // verification_tier: "one".to_string(),
    };

    let ix = Instruction {
        program_id: kycdao_ntnft_id,
        data: InstructionData::data(&anchor_ix),
        accounts: ctx.to_account_metas(None),
    };

    println!("ix: {:?}", ix);

    Ok(ix)
}

pub fn prepare_tx(
    client: &RpcClient,
    backend: Keypair,
    receiver: Pubkey,
    nonce: Pubkey,
) -> Result<Transaction> {

    // Tx for advance nonce account
    let advance_nonce_account_ix = advance_nonce_account(
        &nonce, 
        &backend.pubkey()
    );

    let mint = Keypair::new();

    // Allocate memory for the account
    let min_rent = client.get_minimum_balance_for_rent_exemption(MINT_LAYOUT as usize)?;

    // Create mint account
    let create_mint_account_ix = create_account(
        &receiver,
        &mint.pubkey(),
        min_rent,
        MINT_LAYOUT,
        &TOKEN_PROGRAM_ID,
    );

    // token_program_id: &Pubkey, 
    // mint_pubkey: &Pubkey, 
    // mint_authority_pubkey: &Pubkey, 
    // freeze_authority_pubkey: Option<&Pubkey>, 
    // decimals: u8

    // Initalize mint ix
    let init_mint_ix = initialize_mint(
        &TOKEN_PROGRAM_ID,
        &mint.pubkey(),
        &backend.pubkey(),
        Some(&backend.pubkey()),
        0,
    )?;

    // Create associated account instruction
    let create_assoc_account_ix = create_associated_token_account(
        &receiver, 
        &receiver, 
        &mint.pubkey()
    );

    // Mint to transaction

    // token_program_id: &Pubkey, 
    // mint_pubkey: &Pubkey, 
    // account_pubkey: &Pubkey, 
    // owner_pubkey: &Pubkey, 
    // signer_pubkeys: &[&Pubkey], 
    // amount: u64

    let mint_to_ix = mint_to(
        &TOKEN_PROGRAM_ID,
        &mint.pubkey(),
        &get_associated_token_address(&receiver, &mint.pubkey()),
        &backend.pubkey(),
        &[],
        1,
    )?;

    let kycdao_mint_ix = create_mint_ix(
        client,
        &backend, 
        mint.pubkey(), 
        receiver
    )?;

    let instructions = vec![
        advance_nonce_account_ix,
        create_mint_account_ix,
        init_mint_ix,
        create_assoc_account_ix,
        mint_to_ix,
        kycdao_mint_ix,
    ];
    
    let recent_blockhash = Source::NonceAccount(nonce).get_blockhash(
        client,
        CommitmentConfig::finalized()
    ).unwrap();
    let mut tx = Transaction::new_with_payer(
        &instructions,
        Some(&receiver),
    );
    
    tx.partial_sign(
        &[&mint, &backend],
        recent_blockhash,
    );

    Ok(tx)
}